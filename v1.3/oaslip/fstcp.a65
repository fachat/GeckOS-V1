/****************************************************************************
   
    OS/A65 Version 1.3.11
    Multitasking Operating System for 6502 Computers

    Copyright (C) 1989-1997 Andre Fachat

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

****************************************************************************/

	.(

#include "fstcp.h"

#define	MAXQUEUE	MAXFILES


status	=sysmem
-sysmem	+=MAXFILES
stream	=sysmem
-sysmem	+=MAXFILES
fscmd	=sysmem
-sysmem	+=MAXFILES
fstask	=sysmem
-sysmem	+=MAXFILES
fsqueue	=sysmem
-sysmem	+=MAXQUEUE
fsnq	=sysmem
-sysmem	+=1

fstcp_srv 
        .byte 192,168,0,1, 31, 154, 0,0, 0
        .word fstcp_queue-1, fstcp_loop-1

&fstcp_init .(
#ifndef MMU
	ldx #SEM_SENDBUF
	clc
	jsr PSEM
#endif
	lda #1
	sta PCBUF+FM_REG_DRVS
	lda owntask
	sta PCBUF+FM_REG_ENV
	ldx #SEND_FM
	lda #FM_REG
	ldy #2
	jsr SEND
#ifndef MMU
	php
	ldx #SEM_SENDBUF
	jsr VSEM
	plp
#endif
	bcc ok
	jmp TERM
ok
	ldy #0
	lda #F_FREE
l0	sta status,y
	iny
	cpy #MAXFILES
	bcc l0

	lda #0
	sta fsnq

        lda #<fstcp_srv
        ldy #>fstcp_srv
        jsr tcp_open

	rts
	.)

fstcp_queue .(
	txa
	ldy fsnq
	cpy #MAXQUEUE
	bcs foops		/* shouldn't happen! */
	sta fsqueue,y
	inc fsnq

	clc
	rts
foops	sec
	rts
	.)

fstcp_loop .(
	jsr rxloop
	jsr qloop
	rts
	.)

task	=sysmem
cmd	=sysmem+1
len	=sysmem+2
slot	=sysmem+4
fd	=sysmem+5
-sysmem	+=6

rxloop	.(

	clc
	jsr RECEIVE
	bcc ok
	rts
ok
	stx task
	sty len
	sta cmd

	/* get free fd */
	jsr getfd
	bcs retnofil2
	sty fd

	/* interprete received request */

	ldy #0
	lda len
	clc
	adc #TCP_DOFFSET
	bcc l1
	iny
l1
	jsr balloc
	bcs retnomem2

	sta qp
	sty qp+1
	stx slot

	clc
	adc #TCP_DOFFSET
	sta qd
	tya
	adc #0
	sta qd+1

	/* save stream and prepare PCBUF for sending */
	ldy fd
	lda cmd
	sta fscmd,y
	lda PCBUF+FS_OPEN_STR
	sta stream,y
	tya
	sta PCBUF+FS_OPEN_PFAD
	lda len
	sta PCBUF+FS_OPEN_STR

	ldy #0
	lda #TCP_DOFFSET
	sta (qp),y
	iny
	lda #0
	sta (qp),y
	iny
	lda len
	sta (qp),y
	iny
	lda len+1
	sta (qp),y

	ldy #0
l2	lda PCBUF,y
	sta (qd),y
	iny
	cpy len
	bcc l2

	ldx slot
	jsr tx_queue_packet
retnomem2 bcs retnomem
retnofil2 bcs retnofil

	ldy fd
	lda #F_CMD_SENT
	sta status,y
	lda task
	sta fstask,y

#ifndef NOMMU
	ldx #SEM_SENDBUF
	jsr VSEM
DB("free'd SEM_SENDBUF^m^j")
#endif
	
	lda #E_OK
	clc
	rts

retnomem
DB("retnomem!^m^j")
	lda #E_NOMEM
	.byt $2c
retnofil
	lda #E_NOFILE
	sta PCBUF+FS_X_ERR
	ldy #1
	ldx task
	jsr SEND
	rts
	
	.)

getfd	.(
	ldy #0
	clc
l0	lda status,y
	beq found
	iny
	cpy #MAXFILES
	bcc l0
found	rts
	.)

qloop	.(
	lda fsnq
	bne gotone
	rts
gotone
	/* TODO: this implementation wants each reply in exactly one packet! */
	ldx fsqueue
	jsr getbadr
	sta qp
	sty qp+1

DB("qp=")
lda qp+1:jsr EHexout: lda qp:jsr EHexout
DB(", do=")
ldy #1: lda (qp),y: jsr EHexout
ldy #0: lda (qp),y: jsr EHexout
DB(", l=")
ldy #3: lda (qp),y: jsr EHexout
ldy #2: lda (qp),y: jsr EHexout
jsr ECrlfout

	ldy #0
	lda (qp),y
	clc
	adc qp
	sta qd
	iny
	lda (qp),y
	adc qp+1
	sta qd+1

	iny
	lda (qp),y
	sta len
	iny
	lda (qp),y
	sta len+1

	/* interpret reply packet */
	ldy #FSP_FD
	lda (qd),y
	sta fd
	tay
	lda status,y
	bne noillfd

illfd	DB("illegal FD^m^j")
	ldx fsqueue
	jsr bfree
	jmp nextbuf

noillfd
	ldy #FSP_LEN
	lda (qd),y
	cmp len
	bne illlen
	lda len+1
	beq noilllen

illlen	DB("illegal len^m^j")
	ldx fsqueue
	jsr bfree
	jmp nextbuf
noilllen
	ldy #FSP_CMD
	lda (qd),y
	cmp #FS_REPLY
	bne noreply

	/* first (and only) data byte is reply value */
	lda len
	cmp #4
	bne illlen

#ifndef NOMMU
	sec
	ldx #SEM_SENDBUF
	jsr PSEM
	bcc gotbuf
DB("didn't get SEM_SENDBUF^m^j")
sec
	rts
gotbuf
#endif
	ldy #FSP_DATA
	lda (qd),y
	sta PCBUF+FS_X_ERR
	cmp #E_OK
	bne l1
	lda fscmd,y
	cmp #FS_OPEN_RD
	beq rd
	cmp #FS_OPEN_WR
	beq wr
	cmp #FS_OPEN_DR
	bne l1
rd	lda #F_RD
	.byt $2c
wr	lda #F_WR
	.byt $2c
l1
	lda #F_FREE
	ldy fd
	sta status,y

	ldy fd
	lda fstask,y
	tax
	ldy #FS_X_SLEN
	lda PCBUF+FS_X_ERR
	jsr SEND

	ldx fsqueue
	jsr bfree
ende	
	
noreply	DB("packet not a reply!^m^j")
nextbuf		
	ldy #1
l0	lda fsqueue,y
	dey
	sta fsqueue,y
	iny
	iny
	cpy fsnq
	bcc l0
	dec fsnq
	jmp qloop

	.)

	.)
