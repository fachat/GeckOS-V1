
/****************************************************************************
   
    OS/A65 Version 1.3.11
    Multitasking Operating System for 6502 Computers

    Copyright (C) 1989-1996 Andre Fachat 

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

****************************************************************************/

/*
 * This file is a TCP implementation for 6502 computer
 *
 * it exports:
 *	tcpinit		- init TCP
 *	tcploop		- must be called 
 *	tcprx		- gets incoming packets
 *
 *	tcp_open	- (active) open TCP connection
 *	tcp_listen	- (passive) open TCP connection
 *	tcp_close	- close TCP connection
 *	
 */

#ifndef DB
#define DB(a)
sysmem	=$400
syszp	=$80
#endif

#define	DEBUGTCP

#include "tcp.def"

	.(

tcbp	=syszp
-syszp	+=2

dlen	=sysmem
doffset	=sysmem+2	; data offset from ip!
toffset	=sysmem+3	; tcp header offset from ip!
seg_flag=sysmem+4	; incoming segment flag byte
tslot	=sysmem+5	; incoming segment memory slot
-sysmem	+=6
tcb	=sysmem
-sysmem	+=MAXCONN*TCB_LEN
phdr	=sysmem
-sysmem	+=TPH_LEN

&&tcpinit .(
	ldx #0
i1
	jsr settcb
	lda #TCP_CLOSED
	ldy #TCB_STATE
	sta (tcbp),y
	inx
	cpx #MAXCONN
	bcc i1

	jsr user_init

	clc
	rts
	.)

&&tcploop
	rts

&tcprx	.(

state	=sysmem
conn	=sysmem
-sysmem	+=2

	/* make IP header to TCP pseudo header */
	lda #0
	sta phdr+TH_PTCL-1
	ldy #IPH_PROT
	lda (ip),y
	sta phdr+TH_PTCL
	ldy #IPH_SRC
c1	lda (ip),y
	sta phdr-IPH_SRC,y
	iny
	cpy #IPH_TRG+4
	bne c1
	ldy #TH_TCPLEN
	lda idlen+1
	sta phdr,y
	lda idlen
	sta phdr+1,y

	lda id
	sec
	sbc #TPH_LEN
	sta id
	lda id+1
	sbc #0
	sta id+1

	lda idlen
	clc
	adc #TPH_LEN
	sta idlen
	lda idlen+1
	adc #0
	sta idlen+1

	ldy #0
c2	lda phdr,y
	sta (id),y
	iny
	cpy #TPH_LEN
	bne c2

	lda #<id
	ldy #>id
	jsr checksum2

#ifdef DEBUGTCP
php
pha
txa
pha
DB("TCP Checksum=")
pla
tay
jsr EHexout
pla
pha
jsr EHexout
jsr ECrlfout
tya
tax
pla
plp
#endif
	bcc tcpok

        DB("Packet discarded: TCP checksum^m^j")
        jmp discard

tcpok	/* here we have a valid TCP packet in (id),0-idlen. */

	ldy #TH_FLAG
	lda (id),y
	sta seg_flag

	ldy #TH_DOFFSET
	lda (id),y
	and #$f0
	lsr
	lsr
	clc
	adc #TPH_LEN
	sta doffset
	lda idlen
	sec
	sbc doffset
	sta dlen
	lda idlen+1
	sbc #0
	sta dlen+1

	lda ipl+1
	bne datl
	lda ipl
	sec
	sbc #TPH_LEN
	sta toffset
	clc
	adc doffset
	sta doffset

	bcc looktcb
datl
	DB("Data offset too large^m^j")
	jmp discard
looktcb
	lda islot
	sta tslot
	lda #<-1
	sta islot	; disable re-use of incoming packet

	/* find TCB for this packet */
	.(
lastfre	=sysmem
-sysmem	+=1

	ldx #<-1
	stx lastfre
next	inx
	cpx #MAXCONN
	bcc t1
	ldx lastfre
	jsr settcb
	sec
	jmp ret

t1	jsr settcb

	ldy #TCB_STATE
	lda (tcbp),y
	cmp #TCP_CLOSED
	bne inuse
	stx lastfre
	beq next
inuse	cmp #TCP_LISTEN
	bne search		/* full search */

	ldy #TH_TRGP
iu2	lda (id),y
	cmp (tcbp),y
	bne next
	iny
	cpy #TH_TRGP+2
	bcc iu2
	; ok, we found one. now copy IP addresses and remote port
	ldy #TH_SRCIP
li1	lda (id),y
	sta (tcbp),y
	iny
	cpy #TH_TRGP+2
	bcc li1
	jmp ok
search	
	ldy #TH_SRCP		/* TCB_HDR must be 0! */
tl	lda (id),y
	cmp (tcbp),y
	bne next
	iny
	cpy #TH_TRGP+2
	bcc tl

	ldy #TH_SRCIP
tm	lda (id),y
	cmp (tcbp),y
	bne next
	iny
	cpy #TH_TRGIP+4
	bcc tm
ok	clc
ret	
	.)

	stx conn
	ldy #TCB_STATE
	lda (tcbp),y
	sta state

#ifdef DEBUGTCP
	lda state
	asl
	tax
	lda ttab+1,x
	tay
	lda ttab,x
	jsr ETxtout
	jmp noout

ttab	.word tclosed, tlisten, tsynrxd, tsyntxd, testab, tfinw1, tfinw2
	.word tclosew, tlastack, tclosing, ttimew

tclosed	.asc "Closed:^m^j",0
tlisten	.asc "Listen:^m^j",0
tsynrxd .asc "SynRXd:^m^j",0
tsyntxd .asc "SynTXd:^m^j",0
testab 	.asc "Established:^m^j",0
tfinw1	.asc "FinW1:^m^j",0
tfinw2	.asc "FinW2:^m^j",0
tclosew	.asc "CloseWait:^m^j",0
tlastack .asc "LastAck:^m^j",0
tclosing .asc "Closing:^m^j",0
ttimew	.asc "TimeWait^m^j",0

noout
#endif
	lda state
	asl
	tay
	
	lda stab+1,y
	pha
	lda stab,y
	pha
	rts

stab	.word 	tcp_closed-1, tcp_listen-1, tcp_synrxd-1, tcp_syntxd-1
	.word	tcp_estab-1, tcp_finw1-1,  tcp_finw2-1,  tcp_closew-1
	.word   tcp_lastack-1, tcp_closing-1, tcp_timew-1

tmp	=sysmem
tmp2	=sysmem+1
-sysmem	+=2

tcp_closed .(
	lda seg_flag
	and #THF_RST
	bne end
	lda seg_flag
	and #THF_ACK
	bne ackset

	lda #0
	ldy #TH_SEQ
l0	sta (id),y
	iny
	cpy #TH_SEQ+4
	bcc l0

	clc
	ldy #TH_SEQ+3
	lda (id),y
	adc dlen
	ldy #TH_ACK+3
	sta (id),y
	ldy #TH_SEQ+2
	lda (id),y
	adc dlen+1
	ldy #TH_ACK+2
	sta (id),y
	ldy #TH_SEQ+1
	lda (id),y
	adc #0
	ldy #TH_ACK+1
	sta (id),y
	ldy #TH_SEQ
	lda (id),y
	adc #0
	ldy #TH_ACK
	sta (id),y

	lda #THF_ACK + THF_RST
	bne noack

&send_rst
&listen_ack
ackset	ldy #TH_ACK
	lda (id),y
	ldy #TH_SEQ
	sta (id),y
	ldy #TH_ACK+1
	lda (id),y
	ldy #TH_SEQ+1
	sta (id),y
	ldy #TH_ACK+2
	lda (id),y
	ldy #TH_SEQ+2
	sta (id),y
	ldy #TH_ACK+3
	lda (id),y
	ldy #TH_SEQ+3
	sta (id),y

	lda #THF_RST
noack
	ldy #TH_FLAG
	sta (id),y

	jmp bangbuf
	
end	jmp tdiscard
	.)

tcp_listen .(
	lda seg_flag
	and #THF_RST
	bne listen_rst

	lda seg_flag
	and #THF_ACK
	bne listen_ack

	lda seg_flag
	and #THF_SYN
	bne listen_syn
	jmp nosyn
&listen_syn
	DB("Listen_syn^m^j")
	jsr rxhdr
	bcc okhdr
	jmp disc
okhdr
	jsr hasdata
	beq nodat
	jsr copy_n_queue
nodat
	lda #0
	tay
	jsr chkbuf
	bcc short

	ldy #TH_FLAG
	lda #THF_SYN + THF_ACK
	sta (id),y

	jsr iniseq

	ldy #TCB_STATE
	lda #TCP_SYNRXD
	sta (tcbp),y

	jsr setack
	jsr incuna

	jmp bangbuf

&reset
	DB("Reset rxd!^m^j")
	ldy #TCB_STATE
	lda #TCP_SYNRXD
	sta (tcbp),y
	jmp tdiscard

listen_rst
	DB("Reset while listening^m^j")
	jmp tdiscard
short	DB("Syn packet short^m^j")
	jmp tdiscard
nosyn	DB("Listen but no Syn!^m^j")
disc	jmp tdiscard
	.)

tcp_estab
tcp_finw1  tcp_finw2  tcp_closew tcp_lastack tcp_closing
tcp_timew
tcp_synrxd .(

	/* first, check sequence number */
	jsr checkseq
	bcc seqok

	lda seg_flag
	and #THF_RST
	bne disca	/* discard packet */

	jsr setseq
	jsr setack
	ldy #TH_FLAG
	lda #THF_ACK
	sta (id),y
	jmp bangbuf

disca	jmp tdiscard

seqok	/* second, check the RST bit */
	lda seg_flag
	and #THF_RST
	beq noreset	

	lda state
	cmp #TCP_SYNRXD
	bne seq1

	/* TODO: if from active open, then close! */
	jmp reset	

seq1	cmp #TCP_LASTACK
	bcs seq2

	/* TODO: flush and close everything */
	jmp tdiscard

seq2	/* TODO: close */
	jmp tdiscard

noreset	/* third, check security and precedence... */

	/* fourth, check SYN bit */

	lda seg_flag
	and #THF_SYN
	beq nosyn
	; this is an error - abort anything

	/* TODO: flush everything, close */
	ldy #TCB_STATE
	lda #TCP_CLOSED
	sta (tcbp),y
	jmp send_rst

nosyn	/* fifth, check the ack bit */
	lda seg_flag
	and #THF_ACK
	bne ackok

	DB("No Ack^m^j")
	jmp tdiscard
ackok
	lda state
	cmp #TCP_SYNRXD
	bne ack1

	jsr checkack
	bcc ackok2

badack	DB("Bad Ack in packet^m^j")
	jmp send_rst
ackok2
	ldy #TCB_STATE	/* everything ok -> enter estab and continue... */
	lda #TCP_ESTAB
	sta (tcbp),y
	sta state

ack1	jsr checkack
	bcc a0
	tay
	beq aignore	/* old ack, ignore */

	/* TODO: ack ahead send_next -> send ack, return */
	DB("Ack ahead send_next^m^j")
	jmp tdiscard
a0
	ldy #TH_ACK
a1	lda (id),y
	sta (tcbp),y
	iny
	cpy #TH_ACK+4
	bcc a1
	/* TODO: flush ack'd packets on retransmission queue */
aignore

	/* TODO: check other states here -> state changes */

	/* sixth, check the URG bit */

	/* seventh, process segment text */ 
	
	lda state
	cmp #TCP_ESTAB
	bcc idat
	cmp #TCP_FINW2+1
	bcs idat

	ldy #0
	lda doffset
	sta (ip),y
	tya
	iny
	sta (ip),y
	iny
	lda dlen
	sta (ip),y
	iny
	lda dlen+1
	sta (ip),y

	jsr hasdata
	beq idat
	jsr copy_n_queue	; ok, we need not copy without FIN...
idat	

	/* eighth, check the FIN bit */
	
	lda state
	cmp #TCP_CLOSED
	beq nofin
	cmp #TCP_LISTEN
	beq nofin
	cmp #TCP_SYNTXD
	beq nofin

	lda seg_flag
	and #THF_FIN
	beq nofin

	lda #1
	ldx #0
	jsr addrxnxt
#if 0
	ldy #TCB_RCV_NXT+3
	lda (tcbp),y
	clc
	adc #1
	sta (tcbp),y
	dey
	bcc noinc
	lda (tcbp),y
	adc #0
	sta (tcbp),y
	dey
	bcc noinc
	lda (tcbp),y
	adc #0
	sta (tcbp),y
	dey
	bcc noinc
	lda (tcbp),y
	adc #0
	sta (tcbp),y
noinc
#endif
	jsr setack
	jsr setseq
	ldy #TH_FLAG
	lda #THF_ACK
	sta (id),y
	jsr bangbuf

	lda state
	cmp #TCP_ESTAB+1
	bcs f1
	lda #TCP_CLOSEW
	bne fe

fe	ldy #TCB_STATE
	sta (tcbp),y

f1	
	/* TODO: check other states */

nofin	
tdisc	ldx tslot
	bmi noslot
	jsr bfree
noslot	clc
	rts
	.)

tcp_syntxd .(
	DB("SynTxd^m^j")
jmp tdiscard
#if 0
	lda seg_flag
	pha

	jsr rxhdr
	bcs discp
	pla
	and #THF_SYN + THF_ACK
	beq disc
	cmp #THF_ACK
	beq disc
	pha		; now SYN is set

	/* TODO: send ACK */

	pla
	cmp #THF_SYN
	beq noack
	; here SYN and ACK are set
	lda #TCP_ESTAB
	.byt $2c
noack	lda #TCP_SYNRXD
	ldy #TCB_STATE
	sta (tcbp),y
	rts

discp	pla
disc	jmp discard
#endif
	.)

tdiscard .(
	ldx tslot
	jsr bfree
	clc
	rts
	.)

rxhdr	.(
	lda seg_flag
	and #THF_SYN
	beq nosyn

	ldy #TH_SEQ+3
	clc
	lda (id),y
	adc #1
	sta (id),y
	sta (tcbp),y
	dey 
	lda (id),y
	adc #0
	sta (id),y
	sta (tcbp),y
	dey
	lda (id),y
	adc #0
	sta (id),y
	sta (tcbp),y
	dey
	lda (id),y
	adc #0
	sta (id),y
	sta (tcbp),y
nosyn
	ldy #TH_SEQ	/* we don't handle disordered packets - ignore them */
seql	lda (id),y
	cmp (tcbp),y
	bne seqmismatch
	iny
	cpy #TH_SEQ+4
	bcc seql

	lda seg_flag
	and #THF_ACK
	beq noack
	ldy #TH_ACK	/* TODO: ack larger than send next ? -> send reset */
ackl 	lda (id),y
	sta (tcbp),y
	iny
	cpy #TH_ACK+4
	bcc ackl	/* TODO: remove from retransmission queue */
noack
	jmp doopts

&seqmismatch
	DB("Sequence number mismatch^m^j")
	sec
	rts
	.)

checkseq .(
	ldy #TH_SEQ	/* we don't handle disordered packets - ignore them */
seql	lda (id),y
	cmp (tcbp),y
	bne seqmismatch
	iny
	cpy #TH_SEQ+4
	bcc seql
	clc
	rts
	.)

doopts	.(
	ldy #TH_DOFFSET
	lda (id),y
	and #$f0
	cmp #$60
	bcc no_options
	lsr
	lsr
	clc
	adc #TH_SRCP
	sta tmp2
	ldy #TH_OPTIONS
optloop
	sty tmp
	lda (id),y
	beq no_options
	iny
	cmp #1
	beq optloop
	cmp #2
	bne ill_options	; - ignore illegal options and all following
	; max segment size
	lda (id),y
	pha		; option length
	iny
	lda (id),y	; high
	tax
	iny
	lda (id),y	; low byte
	cpx #>TCPSEG
	bcc oklen
	bne newlen
	cmp #<TCPSEG
	bcc oklen
newlen	lda #<TCPSEG
	ldx #>TCPSEG
oklen 	ldy #TCB_MAXSEG
	sta (tcbp),y
	iny
	txa
	sta (tcbp),y
	pla
	clc
	adc tmp
	tay
	jmp optloop

ill_options
	jsr EHexout
	DB("Illegal header option ^m^j")
	
no_options
	clc
	rts
	.)

p2	=syszp
-syszp	+=2
d2len	=sysmem
-sysmem	+=2

hasdata	.(
	lda dlen
	ora dlen+1
	; bne yes
	rts
	.)

chkbuf	.(
	sta d2len
	sty d2len+1
	lda idlen
	sec
	sbc d2len
	tax
	lda idlen+1
	sbc d2len+1
	bne ret
	cpx #TPH_LEN+24
	;bcc no
ret	rts
	.)

checkack .(
	ldy #TH_ACK
l1	lda (id),y
	cmp (tcbp),y
	bcc badack0
	iny
	cpy #TH_ACK+4
	bcc l1

	lda tcbp
	clc
	adc #4
	sta p2
	lda tcbp+1
	adc #0
	sta p2+1

	ldy #TH_ACK
l2	lda (tcbp),y
	cmp (id),y
	bcc badack1
	iny
	cpy #TH_ACK+4
	bcc l2
	clc
	rts
badack0	lda #0
	.byt $2c
badack1	lda #1
	sec
	rts
	.)


iniseq	.(
	ldy #TCB_SND_NXT
	lda $dc07
	sta (tcbp),y
	iny
	lda $dc06
	sta (tcbp),y
	iny
	lda $dd07
	sta (tcbp),y
	iny
	lda $dd06
	sta (tcbp),y

	sec
	ldy #TCB_SND_NXT+3
	lda (tcbp),y
	sbc #1
	ldy #TCB_SND_UNA+3
	sta (tcbp),y
	ldy #TH_SEQ+3
	sta (id),y
	ldy #TCB_SND_NXT+2
	lda (tcbp),y
	sbc #0
	ldy #TCB_SND_UNA+2
	sta (tcbp),y
	ldy #TH_SEQ+2
	sta (id),y
	ldy #TCB_SND_NXT+1
	lda (tcbp),y
	sbc #0
	ldy #TCB_SND_UNA+1
	sta (tcbp),y
	ldy #TH_SEQ+1
	sta (id),y
	ldy #TCB_SND_NXT
	lda (tcbp),y
	sbc #0
	ldy #TCB_SND_UNA
	sta (tcbp),y
	ldy #TH_SEQ
	sta (id),y
	rts
	.)

bangbuf	.(

	; first exchange port and IP addresses
	lda id
	clc
	adc #TH_TRGP - TH_SRCP
	sta p2
	lda id+1
	adc #0
	sta p2+1

	ldy #TH_SRCP
l1	lda (id),y
	tax
	lda (p2),y
	sta (id),y
	txa
	sta (p2),y
	iny
	cpy #TH_SRCP+2
	bcc l1

	lda id
	clc
	adc #TH_TRGIP - TH_SRCIP
	sta p2
	lda id+1
	adc #0
	sta p2+1

	ldy #TH_SRCIP
l2	lda (id),y
	tax
	lda (p2),y
	sta (id),y
	txa
	sta (p2),y
	iny
	cpy #TH_SRCIP+4
	bcc l2

	; now check syn and add max seg size option if it's syn
	lda seg_flag
	and #THF_SYN
	beq nosyn
	ldy #TH_OPTIONS
	lda #2
	sta (id),y
	iny
	lda #4
	sta (id),y
	iny
	lda #>TCPWIN
	sta (id),y
	iny
	lda #<TCPWIN
	sta (id),y

	lda #$60
	.byt $2c
nosyn	lda #$50
	ldy #TH_DOFFSET
	sta (id),y

	lsr
	lsr
	ldy #TH_TCPLEN+1
	sta (id),y
	clc
	adc #TPH_LEN
	sta idlen
	dey
	lda #0
	sta (id),y
	adc #0
	sta idlen+1

	; this is for other packets also...
	ldy #TH_WINDOW
	lda #>TCPWIN
	sta (id),y
	iny
	lda #<TCPWIN
	sta (id),y

	lda #0
	ldy #TH_CHECK
	sta (id),y
	iny
	sta (id),y
	
	lda #<id
	ldy #>id
	jsr checksum2
	ldy #TH_CHECK+1
	sta (id),y
	dey
	txa
	sta (id),y

	; make IP header from TCP pseudo header
	; (i.e. copy the IP addresses to the right location and set protocol
	; the rest is done in the IP layer

	lda ip
	clc
	adc #TCP_OFFSET
	tax
	lda ip+1
	adc #0
	cmp id+1
	bne move
	cpx id
	beq nomove
move	DB("packet start mismatch!^m^j")
	jmp tdiscard
nomove

	lda idlen
	sec
	sbc #TPH_LEN
	sta idlen
	bcs l4
	dec idlen+1
l4

	lda id
	clc
	adc #4
	sta p2
	lda id+1
	adc #0
	sta p2+1

	ldy #TH_TRGIP+3
l3	lda (id),y
	tax
	lda (p2),y
	sta (id),y
	txa
	sta (p2),y
	dey
	cpy #<TH_SRCIP-1
	bne l3

	ldy #1		; IP_PROT
	lda #6
	sta (ip),y

	lda tslot
	sta islot

#ifdef DEBUGTCP
	DB("Send Seq: ")
	ldy #TH_SEQ
x1	lda (id),y
	jsr EHexout
	iny
	cpy #TH_SEQ+4
	bcc x1
	DB("^m^jSend Ack: ")
	ldy #TH_ACK
x2	lda (id),y
	jsr EHexout
	iny
	cpy #TH_ACK+4
	bcc x2
	DB("^m^jFlag= ")
	ldy #TH_FLAG
	lda (id),y
	jsr EHexout
	jsr ECrlfout
#endif
	lda #<-1
	sta tslot

	jmp sendip
	.)

	/* add a/x to rx_nxt */
addrxnxt .(
	ldy #TCB_RCV_NXT+3
	clc
	adc (tcbp),y
	sta (tcbp),y
	dey
	txa
	adc (tcbp),y
	sta (tcbp),y
	dey
	ldx #2
l5	lda (tcbp),y
	adc #0
	sta (tcbp),y
	dey
	dex
	bne l5
	rts
	.)

incuna	.(
	ldy #TCB_SND_UNA+3
	ldx #3
	lda (tcbp),y
	clc
	adc #1
	sta (tcbp),y
	dey
l5	lda (tcbp),y
	adc #0
	sta (tcbp),y
	dey
	dex
	bne l5
	rts
	.)

setseq	.(
	lda tcbp
	clc
	adc #8
	sta p2
	lda tcbp+1
	adc #0
	sta p2+1

	ldy #TH_SEQ
l5	lda (p2),y
	sta (id),y
	iny
	cpy #TH_SEQ+4
	bcc l5
	rts
	.)

setack	.(
	lda id
	clc
	adc #4
	sta p2
	lda id+1
	adc #0
	sta p2+1

	ldy #TCB_RCV_NXT
l5	lda (tcbp),y
	sta (p2),y
	iny
	cpy #TCB_RCV_NXT+4
	bcc l5
	rts
	.)

/* The following routine takes the packet from 
 * islot/ip/id/ipl/idlen/dlen/doffset/toffset
 * and queues it to the user data rx queue.
 * It sets ack appropriately. 
 * It copies the TCP header into a new packet and sets
 * islot/ip/..., but dlen is zero.
 */
copy_n_queue .(
myslot	=sysmem
-sysmem	+=1
myp	=syszp
-syszp	+=2

	lda doffset
	ldy #0
	jsr balloc
	bcs nobuffer
	stx myslot
	jsr getbadr
	sta myp
	sty myp+1

	ldy #0
l0	lda (ip),y
	sta (myp),y
	iny
	cpy doffset
	bne l0

	ldy #0
	lda doffset
	sta (ip),y		/* save for queue routines */
	tya
	iny
	sta (ip),y
	iny
	lda dlen
	sta (ip),y
	iny
	lda dlen+1
	sta (ip),y

	lda myp
	sta ip
	clc
	adc toffset
	sta id
	lda myp+1
	sta ip+1
	adc #0
	sta id+1

	lda doffset
	sec
	sbc toffset
	sta idlen
	lda #0
	sta idlen+1

	lda tslot
	jsr queue_packet	
	bcs boom

	lda dlen
	ldx dlen+1
	jsr addrxnxt
boom
	lda #0
	sta dlen
	sta dlen+1

	lda myslot
	sta tslot
	clc
nobuffer
	rts
	.)

	.)

settcb	.(
#if (TCB_LEN - 64)
	lda #0
	sta tcbp+1
	txa
	asl
	rol tcbp+1
	asl
	rol tcbp+1
	asl
	rol tcbp+1
	asl
	rol tcbp+1
	asl
	rol tcbp+1
	asl
	rol tcbp+1
	clc
	adc #<tcb
	sta tcbp
	lda #>tcb
	adc tcbp+1
	sta tcbp+1
	rts
#else
#warning TCB length not correct!
#endif
	.)

freetcb	.(
	ldx #0
l0	jsr settcb
	ldy #TCB_STATE
	lda (tcbp),y
	cmp #TCP_CLOSED
	beq l1
	inx
	cpx #MAXCONN
	bcc l0
	sec
	rts
l1	clc
	rts
	.)


/***************************************************************************
 * Here follow the user routines (open, close etc)
 */

srv	=syszp
-syszp	+=2
tcbno	=sysmem
-sysmem	+=1

telnet_srv .byte 0,0,0,0, 0,0, 23,0

+user_init .(
	lda #<telnet_srv
	ldy #>telnet_srv
	jsr tcp_listen
	rts
	.)

+queue_packet .(
zp	=syszp
z2	=syszp+2
-syszp	+=4
slot	=sysmem
-sysmem	+=1

	sta slot
	tax
	jsr getbadr
	sta zp
	sty zp+1

	ldy #0
	lda (zp),y
	clc
	adc zp
	sta z2
	iny
	lda (zp),y
	adc zp+1
	sta z2+1
	iny
	lda (zp),y
	tax
	iny
	lda (zp),y
	sta zp+1
	stx zp

#ifdef DEBUGTCP
DB("Data: pos=")
lda z2+1: jsr EHexout: lda z2: jsr EHexout
DB(" len= ")
lda zp+1: jsr EHexout: lda zp: jsr EHexout
jsr ECrlfout
#endif

dloop	ldy #0
	lda (z2),y
	jsr EHexout
	lda #" "
	jsr ECout

	inc z2
	bne l0
	inc z2+1
l0	lda zp
	bne l1
	dec zp+1
l1	dec zp
	lda zp
	ora zp+1
	bne dloop

	jsr ECrlfout

	ldx slot
	jsr bfree
	rts
	.)

+tcp_listen .(
	sta srv
	sty srv+1
	jsr freetcb
	bcs notcb

	ldy #SRV_LPORT
	lda (srv),y
	tax
	iny
	lda (srv),y
	ldy #TCB_TRGP
	sta (tcbp),y
	iny
	txa
	sta (tcbp),y
	
	ldy #TCB_STATE
	lda #TCP_LISTEN
	sta (tcbp),y
	clc
	;rts
notcb	rts
	.)

	.)

