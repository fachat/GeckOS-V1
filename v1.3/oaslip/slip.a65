
/****************************************************************************
   
    OS/A65 Version 1.3.8
    Multitasking Operating System for 6502 Computers

    Copyright (C) 1989-1996 Andre Fachat 

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

****************************************************************************/


/**********************************************************************/
/* 				SLIP				      */
/*		Serial Line Internet Protocol Driver		      */
/*								      */
/* Driver connects STDIN/OUT with a serial line internet protocol     */
/* 								      */
/* Options:							      */
/*   ROM							      */
/*   NOPRG							      */
/* 								      */
/**********************************************************************/

#ifndef ROM

#define	DEBUG

#define	MY_IP		192,168,0,13
#define	MAXOQUEUE	4

#define	C64

#ifdef C64
#define	STDIOADDR $f000
#endif

#include "oa1sj.a65"
#include "oa1str.def"
#include "oa1fs.def"
#include "stdio.a65"

#ifdef DEBUG
#define	DB(A)	.(:jmp ll0:ll1 .byt A,0:ll0 lda #<ll1:ldy #>ll1:jsr ETxtout:.):
#else
#define	DB(a)
#endif

#define	MAXSLOT	8
#define	IPBUFFER 12*256		/* must be within one (4k) page! */
#define	MTU	1024

/*#define	NOPRG*/

PRGSTART  =$2000

#ifndef SLIPDEV
#define	SLIPDEV	0
#endif

#endif

/**********************************************************************/
/*	SLIP constants						      */

#define	SL_END		192
#define	SL_ESC		219
#define	SL_ESC_END	220	
#define	SL_ESC_ESC	221	

/**********************************************************************/
/*	Internet structs					      */

#define	IPH_VER		0
#define	IPH_SERVICE	1
#define	IPH_LEN		2
#define	IPH_ID		4
#define	IPH_FL		6
#define	IPH_TTL		8
#define	IPH_PROT	9
#define	IPH_CSUM	10
#define	IPH_SRC		12
#define	IPH_TRG		16

#define	ICMP_TYPE	0
#define	ICMP_CODE	1
#define	ICMP_CSUM	2

/**********************************************************************/

          .(
#ifdef ROM

          .word PRGEND
          .byt  PK_PRG
          .byt  8
          .byt  SLIPDEV,SLIPDEV
          .word PRG
#ifndef ROMTEST
          .byt  $8,$8,$9,$9,$a,$a,$b,$b,$c,$c,$d,$d,$e,$e,<-1
#else
          .byt $c,$1c,$d,$1d,$e,$1e,<-1
#endif /* ROMTEST */

          .byt  "shell",0,"shell b c:auto.bat",0

#else /* ROM */

/*------------------------------------------------------------------------*/

#ifndef NOPRG
          ;.word $800
          *=PRGSTART
          .word 0
          .byt PK_PRG
          .byt 8
          .word 0
          .word PRG
          .byt <-1
#else
          .word PRGSTART
          *=PRGSTART

#endif /* NOPRG */

#endif /* ROM */

/*------------------------------------------------------------------------*/

#ifndef NOMMU

syszp     =$80
sysmem    =$1000
sysblk    =$2000

#endif

#echo slip:
#print sysmem
#print sysblk
#print syszp

/**********************************************************************/

PRG	.(

	jsr binit
	bcs exit
DB("^m^jbinit ok^m^j")
	jsr oinit
	bcs exit
DB("^m^joinit ok^m^j")
	jsr startin
DB("startin ok^m^j")
#ifdef DEBUG
jsr printmem
#endif
	bcc doloop
exit	rts

MyIP	.byt MY_IP

doloop
	jsr loopin
	jsr SUSPEND
	jmp doloop

/******************** output loop ***********************/
	.(

onslot	=sysmem
oslot	=sysmem+1
-sysmem	+=MAXOQUEUE+1

&oinit	.(
	lda #0
	sta onslot
	clc
	rts
	.)

&queueslot .(	; queue slot XR for output
	ldy onslot
	cpy #MAXOQUEUE
	bcs drop
	txa
	sta oslot,y
	inc onslot
	rts
drop
	DB("^m^jPacket dropped due to full queue^m^j")
	jsr bfree
	rts
	.)

	.)

/******************** input loop ************************/
	.(

islot	=sysmem
ist	=sysmem+1	; 0=send data, $80= escaped
ilen	=sysmem+2
idlen	=sysmem+4
ihl	=sysmem+6
-sysmem	+=7
ip	=syszp
id	=syszp+2
iend	=syszp+4
-syszp	+=6

&startin
#ifdef DEBUG
jsr printmem
#endif
	lda #<MTU
	ldy #>MTU
	jsr balloc
	bcs oops

	stx islot
iresp	sta ip			/* reset packet */
	sty ip+1
	clc
	adc #<MTU
	sta iend
	tya
	adc #>MTU
	sta iend+1

	lda #0
	sta ist
	clc
oops	rts

&loopin	.(
	ldx #STDIN
	jsr GETC
	bcc gotbyt
	rts
gotbyt
	cmp #SL_END
	beq gotpacket
	cmp #SL_ESC
	bne noesc
	sta ist
	beq loopin
noesc
	bit ist
	bpl noescape
	cmp #SL_ESC_ESC
	beq isesc
	cmp #SL_ESC_END
	bne noescape
	lda #SL_END
	.byt $2c
isesc	lda #SL_ESC
noescape
	ldy #0
	sty ist
	sta (ip),y
	inc ip
	bne l1
	inc ip+1
l1
	lda ip+1
	cmp iend+1
	bcc loopin
	bne discard
	lda ip
	cmp iend
	bcc loopin
discard
	ldx islot
	jsr getbadr
	jmp iresp	; no inloop, because if only SL_ENDs are sent, this
			; would become an almost infinite loop

gotpacket
	ldx islot
	lda ip
	sta iend
	ldy ip+1
	sty iend+1
	and #1
	beq even	; fill up with nullbyte if length is odd
	tay
	lda #0
	sta (ip),y
even
	jsr getbadr
	sta ip
	sty ip+1
	cmp iend
	bne ok
	cpy iend+1
	beq discard	; zero length packet received
ok

#ifdef DEBUG
	/* so what now? */
DB("^m^jReceived Packet:^m^j")
	jsr printpacket

DB("^m^jip=")
lda ip+1:jsr EHexout:lda ip:jsr EHexout
DB("^m^jiend=")
lda iend+1:jsr EHexout:lda iend:jsr EHexout
#endif

	/* sanity checks */
	/* header length */
	ldy #IPH_LEN	; length in hi/lo format in IP header
	lda (ip),y
	sta ilen+1
	iny
	lda (ip),y
	sta ilen

#ifdef DEBUG
DB("^m^jiph->len=")
lda ilen+1
jsr EHexout
lda ilen
jsr EHexout
#endif
	clc
	lda ilen
	adc ip
	php
	cmp iend
	bne discp
	plp
	dey
	lda ilen+1
	adc ip+1
	cmp iend+1
	beq lenok
	php
discp	plp
	jmp discardlen
lenok
	/* header checksum */
	ldy #IPH_VER
	lda (ip),y
	and #$0f
	asl

	pha
	asl
	sta ihl
	clc
	adc ip
	sta id		; start of datagram data
	lda ip+1
	adc #0
	sta id+1

	lda ilen
	sec
	sbc ihl
	sta idlen
	lda ilen+1
	sbc #0
	sta idlen+1
	pla

	tax
	lda ip
	ldy ip+1
	jsr checksum

#ifdef DEBUG
php
pha
txa
pha
DB("^m^jHeader Checksum=")
pla
tay
jsr EHexout
pla
pha
jsr EHexout
jsr ECrlfout
tya
tax
pla
plp
#endif

	bcs discardcs

	/* check my IP address */
	ldy #IPH_TRG
l2 	lda MyIP-IPH_TRG,y
	cmp (ip),y
	bne discardip
	iny
	cpy #IPH_TRG+4
	bcc l2

	/**** so that packet is valid -> process it ****/

	ldy #IPH_PROT
	lda (ip),y

	cmp #1
	bne no
	jmp icmp
no
	jmp discard

discardlen
	DB("^m^jPacket discarded due to length mismatch^m^j")
	jmp discard
discardcs
	DB("^m^jPacket discarded due to checksum^m^j")
disc	jmp discard
discardip
	DB("^m^jPacket discarded due to wrong IP^m^j")
	jmp discard

icmp	.(
	lda ihl
#ifdef DEBUG
pha
jsr EHexout
pla
#endif
	clc 
	adc ip
	pha
#ifdef DEBUG
jsr EHexout
#endif
	lda ip+1
	adc #0
#ifdef DEBUG
pha
jsr EHexout
pla
#endif
	tay
	lda ilen		; well, just take the low byte (TODO)
	clc
	adc ihl
	clc
	adc #1
	lsr
#ifdef DEBUG
pha
jsr EHexout
pla
#endif
	tax
	pla
	jsr checksum

#ifdef DEBUG
php
pha
txa
pha
DB("^m^jICMP Checksum=")
pla
tay
jsr EHexout
pla
pha
jsr EHexout
tya
tax
pla
plp
#endif
	bcc icmpok
	jmp discardcs
icmpok
	ldy #0
	lda (id),y		; icmp type
	cmp #8			; echo message
	beq echo
	jmp discard
echo
	/* ECHO Message */
				; modify message to echo reply message
	lda #0			; icmp echo reply
	sta (id),y

	ldy #IPH_CSUM
	sta (ip),y
	iny
	sta (ip),y
	ldy #IPH_TTL
	lda #64
	sta (ip),y

	ldy #IPH_SRC
	lda (ip),y
	ldy #IPH_TRG
	sta (ip),y
	ldy #IPH_SRC+1
	lda (ip),y
	ldy #IPH_TRG+1
	sta (ip),y
	ldy #IPH_SRC+2
	lda (ip),y
	ldy #IPH_TRG+2
	sta (ip),y
	ldy #IPH_SRC+3
	lda (ip),y
	ldy #IPH_TRG+3
	sta (ip),y

	ldy #IPH_SRC
l0	lda MyIP-IPH_SRC,y
	sta (ip),y
	iny
	cpy #IPH_SRC+4
	bcc l0

	lda ihl
	lsr
	tax
	lda ip
	ldy ip+1
	jsr checksum
	ldy #IPH_CSUM+1
	sta (ip),y
	dey
	txa
	sta (ip),y

	ldy #ICMP_CSUM
	lda #0
	sta (id),y
	iny
	sta (id),y

	lda idlen
	lsr
	tax
	lda id
	ldy id+1
	jsr checksum

	ldy #ICMP_CSUM+1
	sta (id),y
	dey
	txa
	sta (id),y

#ifdef DEBUG
DB("^m^jSend packet:^m^j")
jsr printpacket
#endif
tsx
txa
jsr EHexout
	ldx islot
	lda ilen
	ldy ilen+1
	jsr btrunc

	ldx islot
	jsr queueslot
	jmp startin
	rts
	.)

	.)

	/* computes IP header checksum and returns it in a/x */
	/* TODO: make address (a/y) + # of 16 bit words parameter (x) */
checksum .(

tmp	=sysmem
len	=sysmem+3
-sysmem	+=5
p	=syszp
-syszp	+=2

	sta p
	sty p+1

	txa
	asl
	sta len		; length in byte

	lda #0
	sta tmp
	sta tmp+1
	sta tmp+2
	ldy #0
loop	
	iny
	lda tmp
	clc
	adc (p),y
	sta tmp
	lda tmp+1
	dey
	adc (p),y
	sta tmp+1
	bcc l0
	inc tmp+2
l0
	iny
	iny
	bne l1
	inc p+1
l1
	cpy len
	bcc loop

	lda tmp
	clc
	adc tmp+2
	pha
	lda tmp+1
	adc #0
	eor #$ff
	tax
	pla
	eor #$ff
	bne err
	cpx #0
	bne err
	clc
	rts
err	sec
	rts
	.)

printpacket .(
	ldy #0
l0
	lda (ip),y
	jsr EHexout
	lda #" "
	ldx #STDERR
	jsr Fputc
	iny
	cpy iend
	beq lend
	tya
	and #7
	bne l0
	jsr ECrlfout
	jmp l0
lend
	DB("^m^jHeader Checksum")
	ldy #IPH_VER
	lda (ip),y
	and #$0f
	asl
	tax
	lda ip
	ldy ip+1
	jsr checksum
	pha
	txa
	jsr EHexout
	pla
	jsr EHexout

	DB("^m^jData Checksum")
	lda idlen
	lsr
	tax
	lda id
	ldy id+1
	jsr checksum
	pha
	txa
	jsr EHexout
	pla
	jsr EHexout

	jsr ECrlfout
	clc
	rts


	.)

	.)

/**********************************************************************/
/* Output on STDERR			 			      */

	.(
XR	=sysmem
-sysmem	+=1

&ECrlfout .(
	stx XR
	ldx #STDERR
	lda #13
	jsr Fputc
	lda #10
	jsr Fputc
	ldx XR
	rts
	.)

&EHexout  .(
	  stx XR
          pha
          lsr
          lsr
          lsr
          lsr
          jsr nibout
          pla
          and #$0f
nibout    ldx #STDERR
	  clc
          adc #"0"
          cmp #"9"+1
          bcc nibok
          adc #6
nibok     jsr Fputc
	  ldx XR
	  rts
          .)

&ETxtout
	  .(
tp        =syszp
-syszp	  +=2

          sta tp
          sty tp+1
	  stx XR
	  ldx #STDERR
          ldy #0
tol       lda (tp),y
          beq tole
          jsr Fputc
          iny
          bne tol
          inc tp+1
          bne tol
tole
	  ldx XR
          clc
          rts
          .)

	.)

/**********************************************************************/
/* New memory management for IP buffers 			      */
/* exports							      */
/* 	binit							      */
/* 	balloc, bfree, btrunc, bsplit, brealloc			      */
/*	getbadr, getblen					      */

#define	MINBUF	8
#define	MINMASK	%11111000

	.(

slotladr =sysmem
slothadr =sysmem+MAXSLOT
slotllen =sysmem+MAXSLOT*2
slothlen =sysmem+MAXSLOT*3
-sysmem	+=MAXSLOT*4

flist 	=sysmem
slot	=sysmem+2
-sysmem	+=3

p	=syszp
p2	=syszp+2
p3	=syszp+4
p4	=syszp+6
-syszp	+=8

-sysblk	-=IPBUFFER
buf	=sysblk

/* init memory management */
&binit	.(
	lda #0
	tay
l0	sta slotladr,y
	sta slothadr,y
	iny
	cpy #MAXSLOT
	bcc l0

	sta buf		; freelist start
	sta buf+1
	lda #<IPBUFFER
	sta buf+2
	lda #>IPBUFFER
	sta buf+3
	
	lda #<buf
	sta flist
	lda #>buf
	sta flist+1

	clc
	rts
	.)

/* a/y = size of buffer to be allocated -> x buffer-ID */       
&balloc	.(
	/* walk along freelist, and take first matching buffer 
	   length is made a multiple of 8 (for freelist connectors */

	pha
	jsr getbslot
	pla
	bcc gotslot
	lda #E_NOMEM
	rts
gotslot
	stx slot

	adc #MINBUF-1
	and #MINMASK
	sta slotllen,x
	tya
	adc #0
	sta slothlen,x

#ifdef DEBUG
DB("^m^jalloc(")
txa
jsr EHexout
lda slothlen,x
jsr EHexout
lda slotllen,x
jsr EHexout
DB("^m^jFlist=")
lda flist+1
jsr EHexout
lda flist
jsr EHexout
jsr ECrlfout
#endif	
	lda #0
	sta p2
	sta p2+1
	lda flist
	sta p
	lda flist+1
	sta p+1
l0
#ifdef DEBUG
DB("^m^jCheck@")
lda p+1:jsr EHexout:lda p:jsr EHexout
jsr ECrlfout
#endif
	ldy #2
	lda (p),y
	sec
	sbc slotllen,x
	sta p3
	iny
	lda (p),y
	sbc slothlen,x
	sta p3+1
	bcs found 

	lda p
	sta p2
	lda p+1
	sta p2+1
	dey
	lda (p2),y
	sta p+1
	dey
	lda (p2),y
	sta p
	ora p+1
	bne l0
	
oops	lda #E_NOMEM
	sec
	rts	

found
	/* ok, we found a free buffer: p points to the buffer, p2 to the
	   previous one. p3 is the length of the free buffer minus the
	   needed size. If the buffer is longer than needed, create a 
	   new free buffer, then link new buffer to freelist */

#ifdef DEBUG
DB("^m^jFound Free buffer to alloc:")
DB("^m^jbuffer=")
lda p+1:jsr EHexout:lda p:jsr EHexout
DB("^m^jprevious=")
lda p2+1:jsr EHexout:lda p2:jsr EHexout
DB("^m^jrest len=")
lda p3+1:jsr EHexout:lda p3:jsr EHexout
jsr ECrlfout
#endif

	lda p		/* save buffer address */
	sta slotladr,x
	lda p+1
	sta slothadr,x
		
	lda p3 		/* check length */
	ora p3+1
	beq nocreate
	
	lda p		/* get address of new free buffer */
	clc
	adc slotllen,x
	sta p4
	lda p+1
	adc slothlen,x
	sta p4+1

	ldy #0		/* copy next pointer */
	lda (p),y
	sta (p4),y
	iny
	lda (p),y
	sta (p4),y

	iny		/* set new length */
	lda slotllen,x
	sta (p),y
	lda p3
	sta (p4),y
	iny
	lda slothlen,x
	sta (p),y
	lda p3+1
	sta (p4),y

	lda p4
	sta p
	lda p4+1
	sta p+1

nocreate
	lda p2
	ora p2+1
	beq freestart

	ldy #0
	lda p
	sta (p2),y
	iny
	lda p+1
	sta (p2),y
	clc
	bcc geta
freestart
#ifdef DEBUG
DB("^m^jFreestart")
lda p+1:jsr EHexout:lda p:jsr EHexout:jsr ECrlfout
#endif
	lda p
	sta flist
	lda p+1
	sta flist+1
	clc
geta
	lda slotladr,x
	ldy slothadr,x
	rts
	.)

/* free buffer (ID=xr) */
&bfree	.( 
	lda slothadr,x
	sta p3+1
	lda slotladr,x
	sta p3
	ora p3+1
	beq end2

#ifdef DEBUG
DB("^m^jFreeing Slot ")
txa:jsr EHexout
lda p3+1
jsr EHexout
lda p3
jsr EHexout
jsr ECrlfout
#endif
	ldy #2
	lda slotllen,x
	sta (p3),y
	iny
	lda slothlen,x
	sta (p3),y	

	lda #0
	sta slothadr,x
	sta slotladr,x

	lda flist
	ora flist+1
	bne ok		/* no free buffer so far? */

#ifdef DEBUG
DB("^m^jFreeing...")
lda p3+1:jsr EHexout:lda p3:jsr EHexout:jsr ECrlfout
#endif
	lda p3
	sta flist
	lda p3+1
	sta flist+1
	ldy #0
	tya
	sta (p3),y
	iny
	sta (p3),y
end2	clc
	rts
ok	
	lda #0
	sta p2
	sta p2+1
	lda flist
	sta p
	lda flist+1
	sta p+1

	/* we have to find the place where to put the buffer in the
	   ordered free list. Then we have to check if we can merge
	   free buffers */
loop
#ifdef DEBUG
DB("Check slot @ ")
lda p+1: jsr EHexout
lda p: jsr EHexout
jsr ECrlfout
#endif

	lda p3+1
	cmp p+1
	bcc found
	bne next
	lda p3
	cmp p
	bcc found
next
	lda p
	sta p2
	lda p
	sta p2+1
	ldy #0
	lda (p2),y
	sta p
	iny
	lda (p2),y
	sta p+1
	ora p
	bne loop
	beq found
end
	clc
	rts

found	/* p2 is the buffer before the one to be freed, p the one behind.
	   p3 is the buffer to be inserted */

#ifdef DEBUG
DB("Found buffer^m^j")
DB("p3=")
lda p3+1:jsr EHexout:lda p3:jsr EHexout:jsr ECrlfout
DB("p2=")
lda p2+1:jsr EHexout:lda p2:jsr EHexout:jsr ECrlfout
#endif
	lda p2
	ora p2+1
	bne fok
			; insert before the first free buffer so far
	ldy #0
	lda flist
	sta (p3),y
	iny
	lda flist+1
	sta (p3),y
	lda p3
	sta flist
	ldy p3+1
	sty flist+1
	jsr bmerge
	clc
	rts
fok			; insert to list
	ldy #1
	lda (p2),y
	sta (p3),y
	dey
	lda (p2),y
	sta (p3),y
	lda p3
	sta (p2),y
	iny
	lda p3+1
	sta (p2),y

	lda p3
	ldy p3+1
	jsr bmerge
	lda p2
	ldy p2+1
	jsr bmerge
	clc
	rts
	.)

/* split buffer xr at size a/y for first part. return new buffer ID in x */
&bsplit	.(
	stx slot
	clc
	adc #MINBUF-1
	and #MINMASK
	sta p2
	bcc l0
	iny
l0 	sty p2+1
	tya
	cmp slothlen,x
	bcc ok
	bne oops
	lda p2
	cmp slotllen,x
	bcc ok
	beq oknull
oops	rts
ok	jsr getbslot
	bcs oops
	ldy slot
	clc
	lda slotladr,y
	adc p2
	sta slotladr,x
	lda slothadr,y
	adc p2+1
	sta slothadr,x
	sec
	lda slotllen,y
	sbc p2
	sta slotllen,x
	lda slothlen,y
	sbc p2+1
	sta slothlen,x
	
	lda p2
	sta slotllen,y
	lda p2+1
	sta slothlen,y
	
oknull	clc
	rts
	.)

/* truncate buffer xr to size a/y */
&btrunc	.(
	jsr bsplit
	bcs oops
DB("^m^jBsplit OK!^m^j")

	jmp bfree
oops	rts
	.)

/* realloc buffer xr to size a/y */
/* produce assemble errror
&brealloc .(
	.)
*/

/* get adress of buffer */
&getbadr .(
	lda slotladr,x
	ldy slothadr,x
	clc
	rts
	.)

/* get length of buffer */
&getblen .(
	lda slotllen,x
	ldy slothlen,x
	clc
	rts
	.)

/* get free buffer-ID slot */
getbslot .(
	ldx #0
l0
	clc
	lda slotladr,x
	ora slothadr,x
	beq found
	inx
	cpx #MAXSLOT
	bcc l0
found
	rts
	.)

/* check if two buffers can be merged */
bmerge	.(
	sta p
	sty p+1
	ldy #2
	clc
	lda (p),y
	adc p
	sta p3
	iny
	lda (p),y
	adc p+1
	sta p3+1
	ldy #0
	lda (p),y
	cmp p3
	bne nomerge
	iny
	lda (p),y
	cmp p3+1
	bne nomerge
merge
	ldy #2
	clc
	lda (p3),y
	adc (p),y
	sta (p),y
	iny
	lda (p3),y
	adc (p),y
	sta (p),y
	ldy #0
	lda (p3),y
	sta (p),y
	iny
	lda (p3),y
	sta (p),y
nomerge
	clc
	rts
	.)

#ifdef DEBUG
&printmem .(
DB("^m^jMemory Free List:^m^j")
	lda flist
	sta p
	lda flist+1
	sta p+1
	ldx #STDERR
loop
	lda p+1
	jsr EHexout
	lda p
	jsr EHexout
	lda #"["
	jsr Fputc
	ldy #3
	lda (p),y
	jsr EHexout
	dey
	lda (p),y
	jsr EHexout
	DB("]->")
	ldy #1
	lda (p),y
	jsr EHexout
	dey
	lda (p),y
	jsr EHexout
	jsr ECrlfout

	ldy #1
	lda (p),y
	pha
	dey
	lda (p),y
	sta p
	pla
	sta p+1
	ora p
	bne loop
	rts
	.)
#endif

	.)

#print sysmem
#print sysblk
#print syszp

PRGEND    .)

