
/****************************************************************************
   
    OS/A65 Version 1.3.8
    Multitasking Operating System for 6502 Computers

    Copyright (C) 1989-1996 Andre Fachat 

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

****************************************************************************/


/**********************************************************************/
/* 				SLIP				      */
/*		Serial Line Internet Protocol Driver		      */
/*								      */
/* Driver connects STDIN/OUT with a serial line internet protocol     */
/* 								      */
/* Options:							      */
/*   ROM							      */
/*   NOPRG							      */
/* 								      */
/**********************************************************************/

#ifndef ROM

#define	C64

#ifdef C64
#define	STDIOADDR $f000
#endif

#include "oa1sj.a65"
#include "oa1str.def"
#include "oa1fs.def"
#include "stdio.a65"

#define	DB(A)	.(:jmp ll0:ll1 .byt A,0:ll0 lda #<ll1:ldy #>ll1:jsr Txtout:.):

#define	MAXSLOT	8
#define	IPBUFFER 12*256		/* must be within one (4k) page! */
#define	MTU	1024

/*#define	NOPRG*/

PRGSTART  =$2000

#ifndef SLIPDEV
#define	SLIPDEV	0
#endif

#endif

/**********************************************************************/
/*	SLIP constants						      */

#define	SL_END		192
#define	SL_ESC		219
#define	SL_ESC_END	220	
#define	SL_ESC_ESC	221	

/**********************************************************************/
/*	Internet structs					      */

#define	IPH_VER		0
#define	IPH_SERVICE	1
#define	IPH_LEN		2
#define	IPH_ID		4
#define	IPH_FL		6
#define	IPH_TTL		8
#define	IPH_PROT	9
#define	IPH_CSUM	10
#define	IPH_SRC		12
#define	IPH_TRG		16


          .(
#ifdef ROM

          .word PRGEND
          .byt  PK_PRG
          .byt  8
          .byt  SLIPDEV,SLIPDEV
          .word PRG
#ifndef ROMTEST
          .byt  $8,$8,$9,$9,$a,$a,$b,$b,$c,$c,$d,$d,$e,$e,<-1
#else
          .byt $c,$1c,$d,$1d,$e,$1e,<-1
#endif /* ROMTEST */

          .byt  "shell",0,"shell b c:auto.bat",0

#else /* ROM */

/*------------------------------------------------------------------------*/

#ifndef NOPRG
          ;.word $800
          *=PRGSTART
          .word 0
          .byt PK_PRG
          .byt 8
          .word 0
          .word PRG
          .byt <-1
#else
          .word PRGSTART
          *=PRGSTART

#endif /* NOPRG */

#endif /* ROM */

/*------------------------------------------------------------------------*/

#ifndef NOMMU

syszp     =$80
sysmem    =$1000
sysblk    =$2000

#endif

#echo slip:
#print sysmem
#print sysblk
#print syszp

/**********************************************************************/

PRG	.(

	jsr binit
	bcs exit
DB("^m^jbinit ok^m^j")
	jsr startin
DB("startin ok^m^j")
	bcc doloop
exit	rts

doloop
	jsr loopin
	jsr SUSPEND
	jmp doloop

	.(

islot	=sysmem
ist	=sysmem+1	; 0=send data, $80= escaped
ilen	=sysmem+2
-sysmem	+=4
ip	=syszp
iend	=syszp+2
-syszp	+=4

&startin
	lda #<MTU
	ldy #>MTU
	jsr balloc
	bcs oops

	stx islot
iresp	sta ip			/* reset packet */
	sty ip+1
	clc
	adc #<MTU
	sta iend
	tya
	adc #>MTU
	sta iend+1

	lda #0
	sta ist
	clc
oops	rts

&loopin	.(
	ldx #STDIN
	jsr GETC
	bcc gotbyt
	rts
gotbyt
	cmp #SL_END
	beq gotpacket
	cmp #SL_ESC
	bne noesc
	sta ist
	beq loopin
noesc
	bit ist
	bpl noescape
	cmp #SL_ESC_ESC
	beq isesc
	cmp #SL_ESC_END
	bne noescape
	lda #SL_END
	.byt $2c
isesc	lda #SL_ESC
noescape
	ldy #0
	sty ist
	sta (ip),y
	inc ip
	bne l1
	inc ip+1
l1
	lda ip+1
	cmp iend+1
	bcc loopin
	bne discard
	lda ip
	cmp iend
	bcc loopin
discard
	ldx islot
	jsr getbadr
	jmp iresp	; no inloop, because if only SL_ENDs are sent, this
			; would become an almost infinite loop

gotpacket
	ldx islot
	lda ip
	sta iend
	lda ip+1
	sta iend+1
	jsr getbadr
	sta ip
	sty ip+1
	cmp iend
	bne ok
	cpy iend+1
	beq discard	; zero length packet received
ok
	;lda iend
	;ldy iend+1
	;jsr btrunc	; truncate buffer to needed size

	/* so what now? */
	jsr printpacket

DB("^m^jip=")
lda ip+1:jsr Hexout:lda ip:jsr Hexout
DB("^m^jiend=")
lda iend+1:jsr Hexout:lda iend:jsr Hexout

	/* sanity checks */
	/* header length */
	ldy #IPH_LEN	; length in hi/lo format in IP header
	lda (ip),y
	sta ilen+1
	iny
	lda (ip),y
	sta ilen

DB("^m^jiph->len=")
lda ilen+1
jsr Hexout
lda ilen
jsr Hexout

	clc
	lda ilen
	adc ip
	php
	cmp iend
	bne discp
	plp
	dey
	lda ilen+1
	adc ip+1
	cmp iend+1
	bne discardlen
discp	bne discardlenp

	/* header checksum */
	ldx islot
	jsr checksum

pha
txa
pha
DB("^m^jHeader Checksum=")
pla
tay
jsr Hexout
pla
pha
jsr Hexout
tya
tax
pla

	cmp #<$fffd
	bne discardcs
	cpx #>$fffd
	bne discardcs

	/* TODO: check my IP address */

	ldy #IPH_VER
	and #$0f
	asl
	asl
	tax			; length of IP header

	ldy #IPH_PROT
	lda (ip),y

	cmp #1
	beq icmp

disc	jmp discard

discardlenp
	plp
discardlen
	DB("^m^jPacket discarded due to length mismatch^m^j")
	jmp discard
discardcs
	DB("^m^jPacket discarded due to checksum^m^j")
	jmp discard


icmp	txa
	tay			; first byte of icmp header
	lda (ip),y		; icmp type
	cmp #8			; echo message
	bne disc
				; modify message to echo reply message
	lda #0			; icmp echo reply
	sta (ip),y

	rts

	.)

	/* computes IP header checksum and returns it in a/x */
	/* TODO: make address + # of 16 bit words parameter */
checksum .(

tmp	=sysmem
len	=sysmem+1
-sysmem	+=2
p	=syszp
-syszp	+=2

	jsr getbadr
	sta p
	sty p+1

	ldy #IPH_VER
	lda (p),y
	and #$0f
	asl
	asl
	sta len		; length in byte

	ldx #0
	txa
	sta tmp
	ldy #0
loop	
	iny
	lda tmp
	clc
	adc (p),y
	sta tmp
	txa
	dey
	adc (p),y
	tax

	iny
	iny
	cpy len
	bcc loop

	lda tmp
	rts
	.)

printpacket .(
	lda #<initxt
	ldy #>initxt
	jsr Txtout
	ldy #0
l0
	lda (ip),y
	jsr Hexout
	lda #" "
	jsr Putc
	iny
	cpy iend
	beq lend
	tya
	and #7
	bne l0
	jsr Crlfout
	jmp l0
lend
	clc
	rts

initxt	.byt "^m^jReceived Packet:^m^j",0

	.)

	.)

/**********************************************************************/
/* New memory management for IP buffers 			      */
/* exports							      */
/* 	binit							      */
/* 	balloc, bfree, btrunc, bsplit, brealloc			      */
/*	getbadr, getblen					      */

	.(

slotladr =sysmem
slothadr =sysmem+MAXSLOT
slotllen =sysmem+MAXSLOT*2
slothlen =sysmem+MAXSLOT*3
-sysmem	+=MAXSLOT*4

flist 	=sysmem
slot	=sysmem+2
-sysmem	+=3

p	=syszp
p2	=syszp+2
p3	=syszp+4
p4	=syszp+6
-syszp	+=8

-sysblk	-=IPBUFFER
buf	=sysblk

/* init memory management */
&binit	.(
	lda #0
	tay
l0	sta slotladr,y
	sta slothadr,y
	iny
	cpy #MAXSLOT
	bcc l0

	sta buf		; freelist start
	sta buf+1
	lda #<IPBUFFER
	sta buf+2
	lda #>IPBUFFER
	sta buf+3
	
	lda #<buf
	sta flist
	lda #>buf
	sta flist+1

	clc
	rts
	.)

/* a/y = size of buffer to be allocated -> x buffer-ID */       
&balloc	.(
	/* walk along freelist, and take first matching buffer 
	   length is made a multiple of 8 (for freelist connectors */
	pha
	jsr getbslot
	bcs oops
	stx slot
	pla

	adc #7
	and #%11111000
	sta slotllen,x
	tya
	adc #0
	sta slothlen,x

	lda #0
	sta p2
	sta p2+1
	lda flist
	sta p
	lda flist+1
	sta p+1
l0
	ldy #2
	lda (p),y
	sec
	sbc slotllen,x
	sta p3
	iny
	lda (p),y
	sbc slotllen,x
	sta p3+1
	bcs found 
next
	lda p
	sta p2
	lda p+1
	sta p2+1
	dey
	lda (p2),y
	sta p+1
	dey
	lda (p2),y
	sta p
	ora p+1
	bne l0
	
oops	lda #E_NOMEM
	sec
	rts	

found
	/* ok, we found a free buffer: p points to the buffer, p2 to the
	   previous one. p3 is the length of the free buffer minus the
	   needed size. If the buffer is longer than needed, create a 
	   new free buffer, then link new buffer to freelist */

	lda p		/* save buffer address */
	sta slotladr,x
	lda p+1
	sta slothadr,x
		
	lda p3 		/* check length */
	ora p3+1
	beq nocreate
	
	lda p		/* get address of new free buffer */
	clc
	adc slotllen,x
	sta p4
	lda p+1
	adc slothlen,x
	sta p4+1

	ldy #0		/* copy next pointer */
	lda (p),y
	sta (p4),y
	iny
	lda (p),y
	sta (p4),y

	iny		/* set new length */
	lda p3
	sta (p4),y
	iny
	lda p3+1
	sta (p4),y

	lda p4
	sta p
	lda p4+1
	sta p+1

nocreate
	lda p2
	ora p2+1
	beq freestart

	ldy #0
	lda p
	sta (p2),y
	iny
	lda p+1
	sta (p2),y
	clc
	bcc geta
freestart
	lda p
	sta flist
	lda p+1
	sta flist+1
	clc
geta
	lda slotladr,x
	ldy slothadr,x
	rts
	.)

/* free buffer (ID=xr) */
&bfree	.( 
	lda slothadr,x
	sta p3+1
	lda slotladr,x
	sta p3
	ora p3+1
	beq end

	ldy #2
	lda slotllen,x
	sta (p3),y
	iny
	lda slothlen,x
	sta (p3),y	

	lda #0
	sta slothadr,x
	sta slotladr,x

	lda flist
	ora flist+1
	bne ok		/* no free buffer so far? */

	lda p3
	sta flist
	lda p3+1
	sta flist+1
	ldy #0
	tya
	sta (p3),y
	iny
	sta (p3),y
	clc
	rts
ok	
	lda #0
	sta p2
	sta p2+1
	lda flist
	sta p
	lda flist+1
	sta p+1

	/* we have to find the place where to put the buffer in the
	   ordered free list. Then we have to check if we can merge
	   free buffers */
loop
	lda p3+1
	cmp p+1
	bcc found
	bne next
	lda p3
	cmp p
	bcc found
next
	lda p
	sta p2
	lda p
	sta p2+1
	ldy #0
	lda (p2),y
	sta p
	iny
	lda (p2),y
	sta p+1
	ora p
	bne loop
	beq found
end
	clc
	rts

found	/* p2 is the buffer before the one to be freed, p the one behind.
	   p3 is the buffer to be inserted */
	ldy #1
	lda (p2),y
	sta (p3),y
	dey
	lda (p2),y
	sta (p3),y
	lda p3
	sta (p2),y
	iny
	lda p3+1
	sta (p2),y

	lda p3
	ldy p3+1
	jsr bmerge
	lda p2
	ldy p2+1
	jsr bmerge
	clc
	rts
	.)

/* split buffer xr at size a/y for first part. return new buffer ID in x */
&bsplit	.(
	stx slot
	sta p2
	sty p2+1
	tya
	cmp slothlen,x
	bcc ok
	bne oops
	lda p2
	cmp slotllen,x
	bcc ok
	beq oknull
oops	rts
ok	jsr getbslot
	bcs oops
	ldy slot
	clc
	lda slotladr,y
	adc p2
	sta slotladr,x
	lda slothadr,y
	adc p2+1
	sta slothadr,x
	sec
	lda slotllen,y
	sbc p2
	sta slotllen,x
	lda slothlen,y
	sbc p2+1
	sta slothlen,x
	
	lda p2
	sta slotllen,y
	lda p2+1
	sta slothlen,y
	
oknull	clc
	rts
	.)

/* truncate buffer xr to size a/y */
&btrunc	.(
	jsr bsplit
	bcs oops
	jmp bfree
oops	rts
	.)

/* realloc buffer xr to size a/y */
/* produce assemble errror
&brealloc .(
	.)
*/

/* get adress of buffer */
&getbadr .(
	lda slotladr,x
	ldy slothadr,x
	clc
	rts
	.)

/* get length of buffer */
&getblen .(
	lda slotllen,x
	ldy slothlen,x
	clc
	rts
	.)

/* get free buffer-ID slot */
getbslot .(
	ldx #0
l0
	clc
	lda slotladr,x
	ora slothadr,x
	beq found
	inx
	cpx #MAXSLOT
	bcc l0
found
	rts
	.)

/* check if two buffers can be merged */
bmerge	.(
	sta p
	sty p+1
	ldy #2
	clc
	lda (p),y
	adc p
	sta p3
	iny
	lda (p),y
	adc p+1
	sta p3+1
	ldy #0
	lda (p),y
	cmp p3
	bne nomerge
	iny
	lda (p),y
	cmp p3+1
	bne nomerge
merge
	ldy #2
	clc
	lda (p3),y
	adc (p),y
	sta (p),y
	iny
	lda (p3),y
	adc (p),y
	sta (p),y
	ldy #0
	lda (p3),y
	sta (p),y
	iny
	lda (p3),y
	sta (p),y
nomerge
	clc
	rts
	.)

	.)

#print sysmem
#print sysblk
#print syszp

PRGEND    .)

