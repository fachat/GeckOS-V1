/****************************************************************************
   
    OS/A65 Version 1.3.10
    Multitasking Operating System for 6502 Computers

    Copyright (C) 1989-1996 Andre Fachat 

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

****************************************************************************/


          .(
pz        =syszp
cnt       =syszp+2
-syszp    +=3

#ifndef NOMMU
s1        =syszp
s2        =syszp+1
-syszp    +=2
#else
s1        =sysmem
s2        =sysmem+1
-sysmem   +=2
#endif

#ifndef NOMMU
mmu       .byt SYSPAGE,1,2,3,4,5,6,7,8,9,$a,$b,$c,$d,$e,$f
          ;.byt 0,1,2,3,4,5,6,7,$c,$d,$e,8,9,$a,$b,$18
#endif

+preset   sei 
          cld
#ifndef NOMMU
          ldx #<-2
#else
          ldx #<-1
#endif
          txs
 
#ifndef C64		/* on a C64 we pretty well know what we have */
    
#ifndef ROMTEST

#ifndef NOMMU
          ldx #15
res1      lda mmu,x
          sta MMU,x
          dex
          bpl res1
#endif

          ldx #0
mtl1      lda #$55
          sta 0,x
          cmp 0,x
          bne mtl1e
          asl
          sta 0,x
          cmp 0,x
          bne mtl1e
          lda #0
          sta 0,x
          cmp 0,x
          bne mtl1e
          inx
          bne mtl1

          ; test mirrored memory, 256-byte-wise

#ifndef NOMIRRORMEM
          lda #0
          tay
          sta 0
          sta pz
          tax
          inx
          stx pz+1
m1 
#ifdef BATMEM
          lda (pz),y
          tax
#endif       
          lda pz+1
          sta (pz),y
          lda 0
          bne me
#ifdef BATMEM
          txa
          sta (pz),y
#endif
          inc pz+1
          bpl m1         ; up to 32 kByte

me        lda pz+1
#else
          lda #$80
#endif 			/* NOMIRRORMEM */
          sta cnt
          lda #1
          sta pz+1
mtlx      
#ifdef BATMEM
          lda (pz),y
          tax
#endif
          lda #$55
          sta (pz),y
          cmp (pz),y
          bne mtly
          asl
          sta (pz),y
          cmp (pz),y
          bne mtly
#ifdef BATMEM
          txa
#else
          lda #0
#endif
          sta (pz),y
          cmp (pz),y
          bne mtly
          iny
          bne mtlx
          inc pz+1
          lda pz+1
          cmp cnt
          bcc mtlx
mtly      lda pz+1

#else
          lda #32
#endif			/* ROMTEST */

#else			/* C64 */
	  lda #7
	  sta 0		/* CPU data direction register */
	  lda #5
	  sta 1		/* Memory configuration */

#ifdef CLEARMEM
	  lda #CLEARMEM
	  ldy #2
clear1	  sta 0,y
	  iny 
	  bne clear1
	  ldx #1
	  stx 3
clear2	  sta (2),y
	  iny
	  bne clear2
	  inc 3
	  ldx 3
#if ROMSTART > $d000
	  cpx #$d0	/* keep I/O save */
#else
	  cpx #>ROMSTART
#endif
	  bcc clear2	  
#endif			/* CLEARMEM */
	  lda #>ROMSTART
#endif			/* C64 */

#ifndef NOMMU
          cmp #32        ; 8 k
#else
          cmp #8         ; 2 k
#endif
          bcc mtl3e
          lsr
          lsr
          lsr
          lsr
          sta cnt
          jmp prgstart

mtl1e     ldx #HE_ZP
          .byt $2c
mtl3e     ldx #HE_RAM
          .byt $2c
e1        ldx #HE_IMEM
          .byt $2c
e2        ldx #HE_IDEV
          .byt $2c
e3        ldx #HE_ISTR
          .byt $2c
e4        ldx #HE_IENV
          .byt $2c
erom      ldx #HE_ROM
          .byt $2c
edev      ldx #HE_DEV

          jmp HERROR

+prgstart 
#ifndef NOMMU
          lda #SYSPAGE
          sta MMU
#endif
          jsr getfreq
          sta s1

#ifndef NOSYSPORT
#ifndef NOSINPORT
          lda #SYS_IRQEN+SYS_EXTIO
#else
          lda #SYS_EXTIO
#endif
          sta SYSPORT
#endif
#ifdef LEDPORT
          jsr LEDOFF
#endif

;----------------------------------------------------------------------
/* 
 * C64 specific irq timer init, irq every 20ms 
 * We assume that the reset - or a loader program has disabled all irq 
 */
#ifdef C64		
	  lda #<20000
	  sta C64CIA1+CIA_TBL	; load low byte
	  lda #>20000
	  sta C64CIA1+CIA_TBH	; load hi byte of counter value
 	  lda #%00010001
	  sta C64CIA1+CIA_CRB	; start counter, counting system pulses 
	  lda #%10000010	
	  sta C64CIA1+CIA_ICR	; allow irq
#endif /* C64 */
;----------------------------------------------------------------------

#ifdef NOMMU
#ifdef NMIDEV
          jsr ininmi
#endif
#endif
          jsr inimem
          bcs e1
          jsr inienv
          bcs e4
          lda s1
          jsr inidev
          bcs e2
          jsr inistream 
          bcs e3
          jsr inisem
          jsr fminit     

xl        dec cnt
          bmi x1
          ldx cnt
          cpx #SYSPAGE
          beq xl
          jsr ENMEM
          jmp xl

x1        lda #<ROMSTART
          sta pz
          lda #>ROMSTART
          sta pz+1
startloop 
;	  .byt 2		; x64 trap...

	  ldy #0
          lda (pz),y
          iny
          and (pz),y
          cmp #$ff
          bne slx1

#ifndef C64
#ifdef ROMTEST
#ifndef NOMMU
          ldx MMU+8
          jsr GETBLK
          ldx MMU+9
          jsr GETBLK
          ldx MMU+$a
          jsr GETBLK
          ldx MMU+$b
          jsr GETBLK
          ldx MMU+$c
          jsr GETBLK
          ldx MMU+$d
          jsr GETBLK
          ldx MMU+$e
          jsr GETBLK
          ldx MMU+$f
          jsr GETBLK
#endif
#endif
#endif
          jmp pstart
xerr      jmp edev
endloop   jmp erom

slx1      ldy #P_KIND+2
          lda (pz),y
          bpl slx2
          and #$7f
          cmp #PK_PRG
          beq iprg
          cmp #PK_DEV
          beq idev
          cmp #PK_FS
          beq ifs
slx2      jmp inext

idev      ldy #P_TAB+2
          lda (pz),y
          sta PCBUF+REGDEV_MPOS
          iny
          lda (pz),y
          sta PCBUF+REGDEV_MBLK
          ldy #P_ADR+2
          lda (pz),y
          sta PCBUF+REGDEV_ADR
          iny
          lda (pz),y
          sta PCBUF+REGDEV_ADR+1
          lda #DC_REGDEV
          jsr DEVCMD
          bcs xerr
          jmp inext

ifs       ldx #STDNUL
          stx s1
          stx s2
          bne ifs1

iprg      jsr GETSTR
          bcs endloop
          stx s1
          jsr GETSTR
endloopx  bcs endloop
          stx s2
          ldy #P_RES+2
          lda (pz),y
          tax
          ldy s2
          lda #DC_GS
          jsr DEVCMD
          ldy #P_RES+2
          lda (pz),y
          tax
          ldy s1
          lda #DC_PS
          jsr DEVCMD
          ldy #P_RES+2
          lda (pz),y
          pha
          tax
          lda #DC_RX_ON
          jsr DEVCMD
#ifdef CMOSCPU
	  plx
#else
          pla
          tax
#endif
          lda #DC_TX_ON
          jsr DEVCMD

ifs1      lda s2
          sta PCBUF+FORK_STDOUT
          sta PCBUF+FORK_STDERR
          lda s1
          sta PCBUF+FORK_STDIN

          ldy #P_MEM+2
          lda (pz),y
          tay
          jsr GETENV
          bcs endloopx
          stx PCBUF+FORK_ENV
#ifndef NOMMU
          ldy #P_TAB+2
sl1       sty cnt
          lda (pz),y
          bmi sle;beq sle             ; Erkennung Ende der Tabelle
          tax
          iny
          lda (pz),y
          pha
          txa
          tay
          ldx PCBUF+FORK_ENV
          pla
          sec
          jsr SETBLK
          bcs sln
          tax
          jsr FREMEM
sln       ldy cnt
          iny
          iny
          bne sl1
sle       iny  
          ldx #FORK_NAME
sl2       lda (pz),y
          sta PCBUF,x
          beq sl3
          iny
          inx
          bne sl2
sl3       inx
          iny
          lda (pz),y
          sta PCBUF,x
          bne sl3
          inx
#ifdef CMOSCPU
	  phx
#else
          txa
          pha
#endif
#else
          lda #0
          sta PCBUF+FORK_NAME
          sta PCBUF+FORK_NAME+1
          lda #FORK_NAME+2
          pha
#endif
          ldy #P_ADR+2
          lda (pz),y
          sta PCBUF+FORK_ADR
          iny  
          lda (pz),y
          sta PCBUF+FORK_ADR+1

#ifdef CMOSCPU
	  ply
#else
          pla
          tay
#endif
          jsr FORK

          ldx s1
          lda #SC_NUL
          jsr STRCMD
          ldx s2
          lda #SC_EOF
          jsr STRCMD

inext     ldy #0
          lda (pz),y
          tax
          iny
          lda (pz),y
          sta pz+1
          stx pz
          jmp startloop

#ifdef LEDPORT
+LEDOFF   lda LEDPORT
          ora #LED_LED
          sta LEDPORT
          rts
#endif
/*
+LEDON    lda SYSPORT
          and #255-SYS_LED
          sta SYSPORT
          rts
*/
+HERROR   .(        ; xr=Fehlernummer -1=1mal aus, -2=2mal aus etc
#ifndef C64
/*
#ifndef NOSYSPORT
*/
#ifdef LEDPORT
          LDA LEDPORT:EOR #LED_LED
          STA LEDPORT
          LDY #0:TYA
PRE2      ADC #1:BNE PRE2
          INY:BNE PRE2
          LDA LEDPORT:EOR #LED_LED
          STA LEDPORT
          LDA #0:TAY
PRE3      ADC #1:BNE PRE3:INY
          BNE PRE3:inx:BNE HERROR
          ldx #15
          lda #0:tay
pre5      adc #1:bne pre5
          iny:bne pre5
          dex:bne pre5
#endif
#else /* C64 */
;----------------------------------------------------------------------
/* 
 * in the C64 we blink the border color of the screen to indicate 
 * hardware or init errors 
 */
	  lda #0:sta C64VIC+VIC_EXT_COL
          LDY #0:TYA
PRE2      ADC #1:BNE PRE2
          INY:BNE PRE2
	  inc C64VIC+VIC_EXT_COL
          LDA #0:TAY
PRE3      ADC #1:BNE PRE3:INY
          BNE PRE3:inx:BNE HERROR
	  lda #0:sta C64VIC+VIC_EXT_COL
          ldx #15
          lda #0:tay
pre5      adc #1:bne pre5
          iny:bne pre5
          dex:bne pre5
;----------------------------------------------------------------------
#endif /* C64 */
          JMP RESET 
          .)

          .(
+pnmi
#ifdef C64NMIRESET
	jmp RESET
+ctrlnmi
+setnmi lda #E_NOTIMP
        sec
        rts
#else
#ifdef  NOMMU     
#ifdef  NMIDEV
	  jmp (nmiadr)
          
nmiadr    =sysmem
nmicnt  =sysmem+2
-sysmem   +=3

&ininmi   ;lda #<zend
          ;ldy #>zend
	  lda #NMI_ON		; 0
	  sta nmicnt
ininmi2	  lda #<yendnmi
	  ldy #>yendnmi
n1        sta nmiadr
          sty nmiadr+1
          clc
zend      rts

	  ; struct for CTRLNMI
	  .word $ffff
	  .word zend
yendnmi   rti

+setnmi   jsr memsys
          bcc n2
	  tax
	  lda nmiadr
	  pha
	  lda nmiadr+1
	  pha

	php
	sei
	lda #NMI_OFF
	jsr CTRLNMI	; before we mess with the NMI pointer, switch it off

	txa
        jsr n1

	lda nmiadr
	sec
	sbc #4
	sta tmp
	lda nmiadr+1
	sbc #0
	sta tmp+1

	ldy #0
	lda (tmp),y
	sta tmp2
	iny
	lda (tmp),y
	sta tmp2+1

	tsx
	lda $0102,x	
	sta (tmp2),y
	dey
	lda $0103,x
	sta (tmp2),y

	ldy #2
	lda (tmp),y
	sta tmp2
	iny
	lda (tmp),y
	sta tmp2+1	

	lda #NMI_OFF
 	jsr c2		; init new device with NMI off

	lda #NMI_ON	; now switch on again, if allowed
	jsr CTRLNMI
	plp

	  pla
	  tay
	  pla
          jmp ne
n2        jsr ininmi2
ne        jsr memtask
          rts        

tmp	=syszp
tmp2	=syszp+2
-syszp	+=4
cmd	=sysmem
-sysmem	+=1

+ctrlnmi 
	jsr memsys
	php
	sei
	cmp #NMI_ON
	beq con
	cmp #NMI_OFF
	beq coff
	lda #E_NOTIMP
	.byt $2c
crts	lda #E_OK
	plp
	cmp #1
	jsr memtask
	rts

con 	lda nmicnt
	beq crts
	dec nmicnt
	bne crts
	lda #NMI_ON
	beq nmicmd2

coff	clc
	lda nmicnt
	inc nmicnt
	cmp #0
	bne crts
	lda #NMI_OFF
nmicmd2
	jsr nmicmd		; nmicmd is only called at state change!
	jmp crts

nmicmd
	sta cmd 
	tya
	pha
	txa
	pha
	lda nmiadr
	ldx nmiadr+1

ctrl0	sec
	sbc #4
	sta tmp
	txa
	sbc #0
	sta tmp+1

	ldy #2
	lda (tmp),y
	sta tmp2
	iny
	lda (tmp),y
	sta tmp2+1

	lda cmd
	jsr c2

	ldy #0
	lda (tmp),y	
	sta tmp2
	iny
	lda (tmp),y
	sta tmp2+1
	and tmp2
	cmp #$ff		; address $ffff ?
	beq ce
	lda (tmp2),y
	tax
	dey
	lda (tmp2),y
	jmp ctrl0

ce	clc
	pla
	tax
	pla
	tay
	lda cmd
	clc
	rts

c2	jmp (tmp2)

#else
          rti
+ctrlnmi
+setnmi   lda #E_NOTIMP
          sec
          rts
#endif
#else
          rti
+ctrlnmi
+setnmi   lda #E_NOTIMP
          sec
          rts
#endif
#endif			/* C64 */
          .)

          .(
+pirq     
#ifdef CMOSCPU
	pha
	phy
	phx
#else
	  pha
          tya
          pha
          txa
          pha
#endif
          cld

          tsx
          lda $104,x
          and #$10
          beq pb1

          jmp pbrk

pb1   
#ifndef NOMMU
          lda MMU+1      ; System benutzt MMU+1/+2 z.B. fr read/write
          pha            ; send/receive ....
          lda MMU+2      ; muss bei interruptbaren Fkt erhalten bleiben
          pha
#endif
          jsr memsys
          
#ifndef NOSYSPORT
#ifndef NOSINPORT
          lda SYSPORT    ; save timer-irq state
          pha
#endif
#endif

il        jsr irqdev

#ifndef NOENVIRQ
          jsr irqenv
#endif

#ifndef NOSYSPORT
#ifndef NOSINPORT
          pla
          ora SYSPORT    ; no timer-irq?
          pha            ; save it
          
          lda SYSPORT
          sta SYSPORT    ; clean timer-irq

          jsr testirq    ; irq line still set?
          beq il         ; yes, than back to loop

          pla
          bpl endirq     ; no timer-irq -> no task switch!
#endif
#endif

#ifdef C64
;----------------------------------------------------------------------
/* 
 * as we have set the CIA1 TB irq in the kernel, we have to clear the
 * CIA interrupt flag. This is done with reading the ICRegister.
 * With C64NEEDCIA1 one can disable reading the ICR here. But then you
 * have to have a device that does it!
 */
#ifndef C64NEEDCIA1
	  lda C64CIA1+CIA_ICR	; clear irq flag 
#endif
;----------------------------------------------------------------------
#endif

          bit adev       
          bpl endirq     ; Device Interupted -> no Task-switch
          jmp irqloop

+endirq   jsr memtask
&xendirq
#ifndef NOMMU
          pla
          sta MMU+2
          pla
          sta MMU+1
#endif
&yendirq  
#ifdef CMOSCPU
	plx
	ply
	pla
#else
	  pla
          tax
          pla
          tay
          pla
#endif
          rti
          .)

          .(
&getfreq  
#ifndef NOSYSPORT

#ifndef NOSINPORT
          sei
          lda #SYS_IRQEN
          sta SYSPORT
gf1       lda SYSPORT
          bpl gf1
          sta SYSPORT
          bit SYSPORT
          bmi gf1
          lda #0
          tay
          tax
gf2       bit SYSPORT
          bmi gfe
          clc
          adc #1
          bne gf2
          inx
          bne gf2
          iny
          bne gf2
gfe       cpx #8    ; mehr dann 2 MHZ
          bcc gf3
          lda #128
          rts
gf3       lda #0
          rts
#else               /* ifndef NOSINPORT */
#ifdef CLK2MHZ
          lda #128
#else
          lda #0
#endif
          rts
#endif              /* NOSINPORT        */

#else               /* ifndef NOSYSPORT */
#ifdef CLK2MHZ
          lda #128
#else
          lda #0
#endif
          rts
#endif              /* NOSYSPORT        */
          .)
          
#ifndef NOSYSPORT
#ifndef NOSINPORT
+testirq  .(
          lda SYSPORT
          and #SYS_IRQ
          rts
          .)
#endif
#endif
          .)

